package edu.ucr.cs.riple.core.metadata.field;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.nodeTypes.NodeWithSimpleName;
import com.google.common.collect.Sets;
import edu.ucr.cs.riple.core.metadata.MetaData;
import edu.ucr.cs.riple.injector.Helper;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Detects multiple inline field declarations. An annotation will be injected on top of the field
 * declaration statement, and in inline multiple field declarations that annotation will be
 * considered for all declaring fields. This class is used to detect these cases and adjust the
 * suggested fix instances. (e.g. If we have Object f, i, j; and a Fix suggesting f to be {@code
 * Nullable}, this class will replace that fix with a fix suggesting f, i, and j be {@code
 * Nullable}.)
 */
public class FieldDeclarationAnalysis extends MetaData<FieldDeclarationInfo> {

  /**
   * Constructor for {@link FieldDeclarationAnalysis}.
   *
   * @param path Path to a TSV file containing information about all classes existing in source
   *     code. Each line of this file has the format: (class-flat-name \t uri to file containing the
   *     class). This file is generated by {@link edu.ucr.cs.riple.scanner.Scanner} checker.
   */
  public FieldDeclarationAnalysis(Path path) {
    super(path);
  }

  @Override
  protected FieldDeclarationInfo addNodeByLine(String[] values) {
    // Class flat name.
    String clazz = values[0];
    // Path to class.
    String path = values[1];
    CompilationUnit tree;
    try {
      tree = StaticJavaParser.parse(new File(path));
      NodeList<BodyDeclaration<?>> members =
          Helper.getClassOrInterfaceOrEnumDeclarationMembersByFlatName(tree, clazz);
      if (members == null) {
        return null;
      }
      FieldDeclarationInfo info = new FieldDeclarationInfo(clazz);
      members.forEach(
          bodyDeclaration ->
              bodyDeclaration.ifFieldDeclaration(
                  fieldDeclaration -> {
                    NodeList<VariableDeclarator> vars = fieldDeclaration.getVariables();
                    if (vars.size() > 1) { // Check if it is an inline multiple field declaration.
                      info.addNewSetOfFieldDeclarations(
                          vars.stream()
                              .map(NodeWithSimpleName::getNameAsString)
                              .collect(Collectors.toSet()));
                    }
                  }));
      return info.isEmpty() ? null : info;
    } catch (FileNotFoundException e) {
      return null;
    }
  }

  /**
   * Returns all field names declared within the same declaration statement for any field given in
   * the parameter.
   *
   * @param clazz Flat name of the enclosing class.
   * @param field Subset of all fields declared within the same statement in the given class.
   * @return Set of all fields declared within that statement.
   */
  public Set<String> getInLineMultipleFieldDeclarationsOnField(String clazz, Set<String> field) {
    FieldDeclarationInfo candidate =
        findNodeWithHashHint(node -> node.clazz.equals(clazz), FieldDeclarationInfo.hash(clazz));
    if (candidate == null) {
      // No inline multiple field declarations.
      return Sets.newHashSet(field);
    }
    Optional<Set<String>> inLineGroupFieldDeclaration =
        candidate.fields.stream().filter(group -> !Collections.disjoint(group, field)).findFirst();
    return inLineGroupFieldDeclaration.orElse(Sets.newHashSet(field));
  }
}
